+++
title = "Go を褒め殺ししてみる"
date =  "2021-03-18T20:16:13+09:00"
description = "はやく作って はやく改す"
image = "/images/attention/kitten.jpg"
tags = [ "programming", "language", "engineering", "golang", "rust" ]
pageType = "text"

[scripts]
  mathjax = false
  mermaidjs = false
+++

## 母国語としてのプログラム言語

[以前紹介]({{< ref "/remark/2015/programming-language.md" >}} "プログラミング言語との付き合い方")したのだが，[結城浩](https://www.hyuki.com/)さんの[過去の連ツイ](https://rentwi.hyuki.net/?666213569055166464s)に

{{< fig-quote type="markdown" title="考えてみると結城はC, Perl, Javaの本は書いたけれど..." link="http://rentwi.hyuki.net/?666213569055166464s" >}}
プログラミング言語との付き合い方というのはいろいろあってですね。自分の母国語という言語はある。それから現在学んでいる最中の言語というのもある。そして、仕事用の言語やら、他の人とのコミュニケーション用言語というのもある。そのあたりは、自然言語とちょっと似ている。

ITな業界で仕事をしているひとというのは、だいたいそういう感じでプログラミング言語とつきあっていると思っている。たった一つしかプログラミング言語ができないという人は少なくて、二つくらいは読み書きできる。三つ四つくらいはなんとなく読むのはできる。五つ六つくらいは何のソースか言える。
{{< /fig-quote >}}

という記述がある。

まぁ「仕事用の言語」や「コミュニケーション用言語」ってのは独りで選ぶものではないので今回は除外するとして，「母国語」というのは上手い比喩だ。
自然言語と同じで「母国語」として定着しているプログラミング言語があればロジックや制御への理解も速いし，他言語を習得する際にも有利になる。

でも最初から「◯◯言語を母国語として習得するぞ」とかいう人はいないだろう。
使い込んで手に馴染んでいって初めて「母国語」になり得る。
問題は「どの言語か」ではなく「手に馴染むまで使い込むほどの動機があるか」だと思う。

「これからプログラミングを始めるならどの言語にすればいいか」という問いは今の季節の風物詩みたいなものだが，この問いだけでは「始める」動機が見えないし，その人が既に「母国語」と言えるものを持っているか否かで話も変わってくる。

先日見かけた

- [これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quora](https://jp.quora.com/%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E5%8B%89%E5%BC%B7%E3%81%99%E3%82%8B%E3%81%AA%E3%82%89Golang%E3%81%A8Rust%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%81%8C%E3%81%84%E3%81%84%E3%81%A7%E3%81%97%E3%82%87%E3%81%86)


という記事も似たような印象を受けたが，回答に挙がっている [Rust] と [Go] の比較はなかなか興味深く，また大いに共感した。
ただ，回答された方は [Rust] 寄りみたいなので，対抗して私は [Go] を褒め殺ししてみる（笑）

なお，あらかじめ予防線を張っておくと，私は言語オタクでも文房具オタクでもないし，その手の宗教論争に巻き込まれたくないので，異論反論（当然あると思うけど）には反応しないのであしからず。

（前説おわり）

## はやく作って はやく改（なお）す[^lang1]

[^lang1]: 「改す」を「なおす」と読むのは辞書的に正しい日本語ではありません。念のため（笑）

昔は「はやく作る」というのはスクリプト言語の独壇場だった。
近年のバズワードだった「AI」技術において Python が大きな牽引力として機能しているのは Python が「はやく作る」ことに特化した言語であることも大きいだろう。

しかし [Go] がこの状況を変えていく。

[Go] はコンパイル言語には珍しく（と言っていいのか分からないが）「はやく作る」ことに特化した言語と言っていい。
「はやく作る」というのは事前学習量やコンパイル速度やコード記述量を指しているのではなく「考えたことをそのまま書いて安全に組めるか」ということだ。
[Go] の言語仕様に組み込まれた簡便さも制約もこの目的のためにあると言ってよい。

たとえば [Go] は Java などの伝統的オブジェクト指向プログラミング言語とよく比較されるが，例外処理や継承など「考えたことをそのまま書く」ことにおいてノイズにしかならないギミックをあっさり捨て去っている。
Goroutine 間に優先順位が存在しないのも [`sync`](https://golang.org/pkg/sync/ "sync - The Go Programming Language")`.Mutex` が再入不可なのもちゃんと理由があるのだ（Generics は結局組み込むみたいだけどw）。

ちなみに「はやく作る」ことは「雑に作る」ことではない。
近年の流行語である「[技術的負債]({{< ref "/remark/2020/12/technical-debt-and-hacker.md" >}} "技術的負債とハッカー")」の本来の意図は「はやく作る」ことと引き換えにしているものを金融用語の「負債」に喩えたことだそうだ。つまり技術的負債の「返済」とは，システムやプログラムを「直す」ことではなく「改（なお）す」つまりリファクタリングを指している。

もうひとつの [Go] の特徴は，このリファクタリングに厚い言語であるということだ。
シンプルな言語仕様故に手を入れやすいし， interface 型による「[構造型の部分型付け（structural subtyping）]({{< ref "/remark/2020/04/subtyping.md" >}} "それは Duck Typing ぢゃない（らしい）")」によってオブジェクト間の関係を「疎」にできるため，再利用性の高い機能を別パッケージとして切り離したり，なんなら「出来のよくないパッケージを丸ごと入れ替える」なんてことも比較的容易だったりする。

一言で言うなら「はやく作って はやく改せる」のが [Go] 最大のメリットである。
道具に耽溺するのでなく振り回されるのでなく，自らのアイデアを「いい感じ」に実装する手段としてプログラミング言語を求めるのなら [Go] を選択するのは悪くない，と言っておこう。

## 「文」の制約

[Go の言語仕様][specs]を読むところまで慣れた方なら気づいてると思うけど， [Go] は文（statement）の制約が強い言語である。
文の制約を強くすることで全体の言語仕様をシンプルにしている，とも言えるが。

たとえば `if`, `switch`, `for` といった制御文や `=` などの代入文は式（expression）として評価できないため，式の一部または全部として組み込めない。
分かりやすい例としては C/C++ などでは悪名高いインクリメント[^inc1] “`x++`” は代入構文のバリエーションとして評価されるため，式の一部として組み込めない，とかいったことがある。

```go
y := ary[x++] // syntax error
```

あるいはもっと簡単に

```go
a = b = c = 1 // syntax error
```

とかも無理。

[^inc1]: C/C++ ではインクリメント/デクリメント演算子は前置（++x）と後置（x++）があって機能が異なる。これに起因する不具合も多く，コーディング・ルールで「インクリメント/デクリメントの後置は禁止」とするところが多いらしい。

こういった制約は，特に関数型プログラミング言語から来た人には大きな不満となるだろう。
この理由で [Go] に馴染めないというのであれば [Rust] のほうをお勧めする（笑）

## 富豪的プログラミングの代償

並列処理とメモリ管理はどんな言語でも悩ましい問題である。
特に両者が組み合わさると非常に厄介と言える。

たとえばスクリプト言語や Virtual Machine 上の動作を前提とした処理系ではスクリプト・エンジンや VM が並列処理やメモリ管理の厄介な部分を引き受けてくれるが， [Go] ではこれらを実行モジュールに組み込むことで高いパフォーマンス（とシングル・バイナリでのデプロイ）を可能としている。

[富豪的プログラミング]の観点からは，これらの仕組みはプログラマに有利に働く。
最初の節で紹介した Q&A の回答でも

{{< fig-quote type="markdown" title="これから勉強するならGolangとRustのどちらがいいでしょうか？難易度も含めて推奨お願いします。 - Quora" link="https://jp.quora.com/%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E5%8B%89%E5%BC%B7%E3%81%99%E3%82%8B%E3%81%AA%E3%82%89Golang%E3%81%A8Rust%E3%81%AE%E3%81%A9%E3%81%A1%E3%82%89%E3%81%8C%E3%81%84%E3%81%84%E3%81%A7%E3%81%97%E3%82%87%E3%81%86" >}}
言語仕様が小さくて、コンパイルがとても速く、GC (Garbage Collector)を採用してメモリ管理の煩わしさをなくすとともに、並列実行を容易にしています。

その分、単体での実行速度については妥協していますが、速度を求めるのなら処理を並列化しつつマシン側（実行環境）を増強すれば良い、というクラウド時代の解決策をとっています。つまり、コードのちまちまとした最適化で悩んでいる暇があるなら札束で殴ってさっさと解決しろ、ということですね。とても効率的な考え方です。
{{< /fig-quote >}}

と解説されている。まさに富豪的（笑）

しかし，これと引き換えに「小さなシステム」に対しては無視できない代償を支払っている。
これは並列処理やメモリ管理を実行バイナリに埋め込むために POSIX への依存度が高くなっているためだ。

小さなシステムやシビアなリアルタイム処理[^rt1] には [Go] は向かないだろう。ましてやデバイスドライバや pure [Go] な OS カーネルなど夢のまた夢である。
そういうものに興味があるのであれば [Rust] のほうがお勧めだ。

[^rt1]: ここでいうリアルタイム処理とは「分割されたジョブを決められたタイミングで決められた期間内に完了すること」を指す。

なお，個人的に興味を持っている [TinyGo] なら LLVM ベースの小さいバイナリを生成することができる。組み込み用途であればこういった選択肢はありだと思う。

本当は WebAssembly に[興味がある]({{< ref "/golang/webassembly-with-tinygo.md" >}} "TinyGo で WebAssembly")のだが，少なくとも [Go] 側が WASI (WebAssembly System Interface) をサポートしてくれないと無理かなぁ。

[Go]: https://golang.org/ "The Go Programming Language"
[TinyGo]: https://tinygo.org/ "TinyGo - Go on Microcontrollers and WASM"
[specs]: https://golang.org/ref/spec "The Go Programming Language Specification - The Go Programming Language"
[Rust]: https://www.rust-lang.org/ "Rust Programming Language"
[富豪的プログラミング]: http://www.pitecan.com/fugo.html

## 参考図書

{{% review-paapi "4621300253" %}} <!-- プログラミング言語Go -->
{{% review-paapi "4873118557" %}} <!-- プログラミングRust -->
{{% review-paapi "4621303252" %}} <!-- Effective Java 第3版 -->

